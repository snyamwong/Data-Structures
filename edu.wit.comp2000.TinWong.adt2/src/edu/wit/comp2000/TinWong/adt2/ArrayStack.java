package edu.wit.comp2000.TinWong.adt2;import java.util.EmptyStackException;/** * A class of stacks whose entries are stored in an array. *  * @author Tin Wong * @class COMP 2000  * @assignment ADT 2 Stack Implementation * @DueDate 10/11/16 *  *  */public class ArrayStack<T> implements StackInterface<T> {	/**	 * Main method, tests the methods for Stack ADT	 * 	 * @param args	 */	public static void main(String[] args) {		// Create a Stack ADT (capacity is 2)		ArrayStack<String> stack = new ArrayStack<>(2);		// tested all the cases here, console messages		// are in the methods to clean up the main method space		System.out.println("Is stack empty? " + stack.isEmpty());		stack.push("Tin");		stack.peek();		stack.push("Yam");		stack.peek();		stack.push("Wong");		stack.peek();		stack.push("Not Tin Yam Wong");		stack.peek();		stack.pop();		stack.peek();		stack.pop();		stack.peek();		stack.pop();		stack.peek();		stack.push("Tin");		stack.peek();		System.out.println("Is stack empty? " + stack.isEmpty());		stack.clear();		System.out.println("Is stack empty? " + stack.isEmpty());	}	private T[] stack; // Array of stack entries	private int topIndex; // Index of top entry	private boolean initialized = false;	private static final int DEFAULT_CAPACITY = 50;	private static final int MAX_CAPACITY = 10000;	/**	 * 	 */	public ArrayStack() {		this(DEFAULT_CAPACITY);	} // end default constructor	/**	 * 	 * @param initialCapacity	 */	public ArrayStack(int initialCapacity) {		checkCapacity(initialCapacity);		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] tempStack = (T[]) new Object[initialCapacity];		stack = tempStack;		topIndex = initialCapacity;		initialized = true;	} // end constructor	// < Implementations of the stack operations go here. >	// < Implementations of the private methods go here; checkCapacity and	// checkInitialization are analogous to those in Chapter 2. >	// . . .	// Throws an exception if the client requests a capacity that is too large	/**	 * 	 * @param initialCapacity	 */	private void checkCapacity(int initialCapacity) {		// TODO Auto-generated method stub		if (initialCapacity > MAX_CAPACITY)			throw new IllegalStateException(					"Attempt to create a stack " + "whose capacity exceeds " + "allowed maximum.");	} // end checkCapacity	// Throws an exception if this object is not initialized	/**	 * 	 */	private void checkInitialization() {		// TODO Auto-generated method stub		if (!initialized)			throw new SecurityException("ArrayStack object is not initialized properly.");	} // end checkInitialization	/**	 * 	 */	private void ensureCapacity() {		// The array is "full" when topIndex == 0, this is used to ensure		// the stack's bottom entry are at the top of the stack		// instead of at the bottom		if (topIndex == 0) // If array is "full", double its size		{			System.out.println("Running ensureCapacity: ");			int newLength = 10 * stack.length;			System.out.println("New length: " + newLength);			checkCapacity(newLength);			//there are easier methods (such as System.arraycopy() method or 			//Arrays.copyOf()), however I did a for loop - albeit it is a bit sloopy			@SuppressWarnings("unchecked")			T copy[] = (T[]) new Object[newLength];						//newArrayIndex is a counter to decrement the array copy's index			int newArrayIndex = 1;			for (int i = stack.length - 1; i >= 0; i--) {				copy[newLength - newArrayIndex] = stack[i];				//also I need to renew the topIndex 				topIndex = newLength - newArrayIndex;				newArrayIndex++;			}						//then I just make stack to contain the copy array			stack = copy;					} // end if	} // end ensureCapacity	/**	 * 	 */	@Override	public void push(T newEntry) {		// TODO Auto-generated method stub		checkInitialization();		ensureCapacity();		// Console messages to help clarity, prints out the length of the stack		System.out.println("Pre push: " + topIndex);		// Bottom entries are at the top		stack[topIndex - 1] = newEntry;		// Move index one down		topIndex--;		System.out.println("Post push: " + topIndex);	} // end push	/**	 * 	 */	@Override	public T pop() {		// TODO Auto-generated method stub		checkInitialization();		if (isEmpty()) {			throw new EmptyStackException();		} else {			// Take the "top" entry out, then making it a null entry			T top = stack[topIndex];			stack[topIndex] = null;			// Console system message for clarity, Stack's length is shown			System.out.println("Pre pop (topIndex): " + topIndex);			// Pop one out means you move up on the Stack			topIndex++;			System.out.println("Post pop (topIndex): " + topIndex);			return top;		} // end if	} // end pop	/**	 * 	 */	@Override	public T peek() {		// TODO Auto-generated method stub		checkInitialization();		if (isEmpty())			throw new EmptyStackException();		else			System.out.println("Peeking the bag rn: " + stack[topIndex]);		return stack[topIndex];	} // end peek	/**	 * 	 */	@Override	public boolean isEmpty() {		// TODO Auto-generated method stub		// topIndex equals stack.length (instead of zero) because		// topIndex starts out at stack.length, to ensure		// bottom entries are on the top (stack[stack.length -1])		return topIndex == stack.length;	} // end isEmpty	/**	 * 	 */	@Override	public void clear() {		// TODO Auto-generated method stub		checkInitialization();		// Remove references to the objects in the stack,		// but do not deallocate the array		// Same logic as isEmpty(), where array is empty		// only when it reaches stack.length		while (topIndex != stack.length) {			stack[topIndex] = null;			topIndex++;		} // end while		// Assertion: topIndex is stack.length	} // clear} // end ArrayStack