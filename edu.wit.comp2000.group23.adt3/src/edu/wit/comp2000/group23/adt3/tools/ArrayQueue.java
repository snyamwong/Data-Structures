package edu.wit.comp2000.group23.adt3.tools;/** * A class that implements the ADT queue by using an expandable circular array * with one unused location. (ROSENBURG DOES NOT WANT THE UNUNUSED LOCATION) *  * @author Tin Wong * @DueDate 10/23/16 *  */public final class ArrayQueue<T> implements QueueInterface<T> {	private T[] queue; 	private int frontIndex;	private int backIndex;	//numberOfEntries to track entries for ArrayQueue	private int numberOfEntries;	private boolean initialized = false;	private static final int DEFAULT_CAPACITY = 50;	private static final int MAX_CAPACITY = 10000;		/**	 * Default constructor for ArrayQueue	 */	public ArrayQueue() {		this(DEFAULT_CAPACITY);	} // end default constructor		/**	 * Constructor for ArrayQueue with parameter of initialCapacity	 * @param initialCapacity	 */	public ArrayQueue(int initialCapacity) {		checkCapacity(initialCapacity);		// The cast is safe because the new array contains null entries		@SuppressWarnings("unchecked")		T[] tempQueue = (T[]) new Object[initialCapacity + 1];		queue = tempQueue;		frontIndex = 0;		backIndex = queue.length - 1;		initialized = true;	} // end constructor	// < Implementations of the queue operations go here. >	// . . .		@Override	/**	 * Add to entry to the backIndex	 * @param newEntry	 */	public void enqueue(T newEntry) {		// TODO Auto-generated method stub		checkInitialization();		ensureCapacity();		backIndex = (backIndex+1) % queue.length;		queue[backIndex] = newEntry;		numberOfEntries++;	}		/**	 * MAX_CAPACITY is 10,000, if exceeds then throw exception	 * @param initialCapacity	 */	private void checkCapacity(int initialCapacity) {		// TODO Auto-generated method stub		if (initialCapacity > MAX_CAPACITY) {			throw new IllegalStateException(					"Attempt to create a queue " + "whose capacity exceeds " + "allowed maximum.");		}	}		/**	 * doubles the capacity if the array is full	 */	private void ensureCapacity() {		// TODO Auto-generated method stub		if (frontIndex == ((backIndex + 2) % queue.length)) // if array is full,		{ // double size of array			T[] oldQueue = queue;			int oldSize = oldQueue.length;			int newSize = 2 * oldSize;			checkCapacity(newSize);			// The cast is safe because the new array contains null entries			@SuppressWarnings("unchecked")			T[] tempQueue = (T[]) new Object[2 * oldSize];			queue = tempQueue;			for (int index = 0; index < oldSize; index++) {				queue[index] = oldQueue[frontIndex];				frontIndex = (frontIndex + 1) % oldSize;			} // end for			frontIndex = 0;			backIndex = oldSize - 2;		}	}		/**	 * use when enqueue || dequeue	 */	private void checkInitialization() {		// TODO Auto-generated method stub		if (!initialized) {			throw new SecurityException("ArrayQueue object is not initialized properly.");		}	}	@Override	/**	 * removes the front of the queue	 */	public T dequeue() {		// TODO Auto-generated method stub		checkInitialization();		if (isEmpty())			throw new EmptyQueueException();		else {			T front = queue[frontIndex];			queue[frontIndex] = null;			frontIndex = (frontIndex + 1) % queue.length;			numberOfEntries--;			return front;		}			}	@Override	/**	 * returns the front of the queue	 */	public T getFront() {		// TODO Auto-generated method stub		checkInitialization();		if (isEmpty())			throw new EmptyQueueException();		else			return queue[frontIndex];	}	@Override	/**	 * Tests if queue is empty, uses numberOfEntries	 */	public boolean isEmpty() {		// TODO Auto-generated method stub		return numberOfEntries == 0;	}	@Override	/**	 * Clears the queue, uses a while loop with dequeue()	 */	public void clear() {		// TODO Auto-generated method stub		checkInitialization();		while (!isEmpty())        {            dequeue();        }	}		/**	 * Return size of the queue	 * @return	 */	public int size(){		return this.numberOfEntries;	}		/**	 * Main method	 * @param args	 */	public static void main(String[] args){		ArrayQueue<String> queue = new ArrayQueue<>(2);				//queue adds six (Strings) into the queue		//since the queue's size is only 2, it will only run if ensureCapacity() works		System.out.println("Is queue empty? " + queue.isEmpty());				System.out.println("Enqueue six (Strings). . .");				queue.enqueue("Tin");		queue.enqueue("Yam");		queue.enqueue("Wong");		queue.enqueue("Tin");		queue.enqueue("Yam");		queue.enqueue("Wong");				System.out.println("Is queue empty? " + queue.isEmpty());		System.out.println(queue.size());				//dequeue to read Tin Yam Wong, since FIFO		System.out.println("Get front of queue: " + queue.getFront());		queue.dequeue();		System.out.println("Get front of queue: " + queue.getFront());		queue.dequeue();		System.out.println("Get front of queue: " + queue.getFront());		queue.dequeue();				System.out.println("Is queue empty? " + queue.isEmpty());				System.out.println("Clearing queue.. . ");		queue.clear();		System.out.println("Is queue empty? " + queue.isEmpty());	}} // end ArrayQueue